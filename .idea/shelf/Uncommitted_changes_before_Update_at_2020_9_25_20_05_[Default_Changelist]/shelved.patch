Index: src/comp1110/ass2/FitGame.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package comp1110.ass2;\r\n\r\nimport java.util.*;\r\n\r\n\r\n/**\r\n * This class provides the text interface for the IQ Fit Game\r\n * <p>\r\n * The game is based directly on Smart Games' IQ-Fit game\r\n * (https://www.smartgames.eu/uk/one-player-games/iq-fit)\r\n */\r\n\r\npublic class FitGame {\r\n    public static int[][] Board = {{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0}};\r\n    public static String solution = \"\";\r\n    public static int tlx = -1;\r\n    public static int tly = -1;\r\n    public static void initial(){\r\n        Board =new int[][] {{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0}};\r\n    }\r\n    /**\r\n     * Create a new Piece according to the string that describe the piece\r\n     *\r\n     * @param: the String that describe piece\r\n     *\r\n     * @return The piece in type Piece\r\n     */\r\n\r\n    public static boolean checkCompletion(){\r\n        for (int i =0;i<5;i++){\r\n            for(int j=0;j<10;j++){\r\n                if (Board[i][j]!=1){\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    public static Piece createNewPiece(String thisPiece){\r\n        if (isPiecePlacementWellFormed(thisPiece))\r\n            return new Piece(thisPiece);\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Add a new piece on the board, this will include checking\r\n     * if the placement viable. If so, the method will update\r\n     * the board[][] as well as update the string\r\n     *\r\n     * @param: the current String that describe piece on the\r\n     *          board, the piece that want to add\r\n     * @return The new string, it will not change if the placement\r\n     *           is not viable.\r\n     */\r\n    public static void addToBoard(String thisPiece){\r\n        Piece temp = createNewPiece(thisPiece);\r\n        int[][] tempMat = temp.toMatrix();\r\n        int tempX = temp.getTopLeftX();\r\n        int tempY = temp.getTopLeftY();\r\n        int rows = tempMat.length;\r\n        int columns = tempMat[0].length;\r\n        for (int i = 0; i < columns; i++){\r\n            for (int j = 0; j < rows; j++){\r\n                if (tempMat[j][i] == 1)\r\n                    Board[j + tempY][i + tempX] = 1;\r\n            }\r\n        }\r\n    }\r\n    public static void deleteFromBoard(String thisPiece){\r\n        Piece temp = createNewPiece(thisPiece);\r\n        int[][] tempMat = temp.toMatrix();\r\n\r\n        int tempX = temp.getTopLeftX();\r\n        int tempY = temp.getTopLeftY();\r\n        int rows = tempMat.length;\r\n        int columns = tempMat[0].length;\r\n        for (int i = 0; i < columns; i++){\r\n            for (int j = 0; j < rows; j++){\r\n                if (tempMat[j][i] == 1)\r\n                    Board[j + tempY][i + tempX] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if this piece is conflict with other piece on board\r\n     *\r\n     * @param: the String that describe the piece\r\n     *\r\n     * @return The piece in type Piece\r\n     */\r\n    public static boolean canPieceBePlaced(String thisPiece){\r\n        if (!isPiecePlacementWellFormed(thisPiece))\r\n            return false;\r\n        Piece temp = createNewPiece(thisPiece);\r\n        int[][] tempMat = temp.toMatrix();\r\n        int tempX = temp.getTopLeftX();\r\n        int tempY = temp.getTopLeftY();\r\n        int rows = tempMat.length;\r\n        int columns = tempMat[0].length;\r\n        for (int i = 0; i < columns; i++){\r\n            for (int j = 0; j < rows; j++){\r\n                if (tempMat[j][i] == 1){\r\n                    if (tempX + i > 9 || tempY + j > 4)\r\n                        return false;\r\n                    else{\r\n                        if (Board[j + tempY][i + tempX] == 1)\r\n                            return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * check if the piece (or its brother) has been used\r\n     *\r\n     * @param placement A string describing a placement of one or more pieces\r\n     * @return True if all pieces are not used.\r\n     */\r\n    public static boolean havePiecesBeenUsed(String placement){\r\n        if(!isPlacementWellFormed(placement))\r\n            return false;\r\n        char[] T = {'B','R','G','I','L','N','O','P','S','Y'};\r\n        boolean[] check = new boolean[10];\r\n        String temp = placement.toUpperCase();\r\n        for (int i = 0; i < placement.length(); i += 4){\r\n            for (int j = 0; j < 10; j++){\r\n                if(T[j] == temp.charAt(i)){\r\n                    if (check[j])\r\n                        return false;\r\n                    else\r\n                        check[j] = true;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Determine whether a piece placement is well-formed according to the\r\n     * following criteria:\r\n     * - it consists of exactly four characters\r\n     * - the first character is a valid piece descriptor character (b, B, g, G, ... y, Y)\r\n     * - the second character is in the range 0 .. 9 (column)\r\n     * - the third character is in the range 0 .. 4 (row)\r\n     * - the fourth character is in valid orientation N, S, E, W\r\n     *\r\n     * @param piecePlacement A string describing a piece placement\r\n     * @return True if the piece placement is well-formed\r\n     */\r\n\r\n    static boolean isPiecePlacementWellFormed(String piecePlacement) {\r\n        if (piecePlacement.length() != 4)\r\n            return false;\r\n        char C1 = piecePlacement.toUpperCase().charAt(0), C2 = piecePlacement.charAt(1), C3 = piecePlacement.charAt(2), C4 = piecePlacement.charAt(3);\r\n        if (C1!='B' && C1!='R' && C1!='G' && C1!='I' && C1!='L' && C1!='N' && C1!='O' && C1!='P' && C1!='S' && C1!='Y')\r\n            return false;\r\n        if (C2<48 || C2>57)\r\n            return false;\r\n        if (C3!='0' && C3!='1' && C3!='2' && C3!='3' && C3!='4')\r\n            return false;\r\n        if (C4!='N' && C4!='S' && C4!='E' && C4!='W')\r\n            return false;\r\n        return true; // FIXME Task 2: determine whether a piece placement is well-formed\r\n    }\r\n\r\n    /**\r\n     * Determine whether a placement string is well-formed:\r\n     * - it consists of exactly N four-character piece placements (where N = 1 .. 10);\r\n     * - each piece placement is well-formed\r\n     * - no shape appears more than once in the placement\r\n     * - the pieces are ordered correctly within the string\r\n     *\r\n     * @param placement A string describing a placement of one or more pieces\r\n     * @return True if the placement is well-formed\r\n     */\r\n    public static boolean isPlacementWellFormed(String placement) {\r\n        if (placement.length() % 4 != 0|| placement.equals(\"\")){\r\n            return false;\r\n        }\r\n        int N = placement.length() / 4;\r\n        for (int i = 0; i < N; i++){\r\n            for (int j = i + 1; j < N; j++){\r\n                if (placement.charAt(i*4) == placement.charAt(j*4))\r\n                    return false;\r\n                if ((int)placement.charAt(i*4) >= 91 && (int)placement.charAt(j*4) <= 'Z'){\r\n                    if (placement.charAt(i*4)-32 > placement.charAt(j*4))\r\n                        return false;\r\n                }\r\n                else if (placement.charAt(i*4) <= 'Z' && placement.charAt(j*4) >= 'a'){\r\n                    if (placement.charAt(i*4)>placement.charAt(j*4)-32)\r\n                        return false;\r\n                }\r\n                else {\r\n                    if (placement.charAt(i*4)>placement.charAt(j*4))\r\n                        return false;\r\n                }\r\n            }\r\n            if (!isPiecePlacementWellFormed(placement.substring(i*4, i*4 +4)))\r\n                return false;\r\n        }\r\n        return true; // FIXME Task 3: determine whether a placement is well-formed\r\n    }\r\n\r\n    /**\r\n     * Determine whether a placement string is valid.\r\n     *\r\n     * To be valid, the placement string must be:\r\n     * - well-formed, and\r\n     * - each piece placement must be a valid placement according to the\r\n     *   rules of the game:\r\n     *   - pieces must be entirely on the board\r\n     *   - pieces must not overlap each other\r\n     *\r\n     * @param placement A placement string\r\n     * @return True if the placement sequence is valid\r\n     */\r\n    public static boolean isPlacementValid(String placement) {\r\n        if (!isPlacementWellFormed(placement))\r\n            return false;\r\n        initial();\r\n        int[][] tempBoard = Board;\r\n        for (int n = 0; n < placement.length()/4; n++){\r\n            String stringForThisPiece = placement.substring(n * 4, n * 4 + 4);\r\n            Piece temp = createNewPiece(stringForThisPiece);\r\n            int[][] tempMat = temp.toMatrix();\r\n            int tempX = temp.getTopLeftX();\r\n            int tempY = temp.getTopLeftY();\r\n            int rows = tempMat.length;\r\n            int columns = tempMat[0].length;\r\n            for (int i = 0; i < columns; i++){\r\n                for (int j = 0; j < rows; j++){\r\n                    if (tempMat[j][i] == 1){\r\n                        if (tempX + i > 9 || tempY + j > 4)\r\n                            return false;\r\n                        else{\r\n                            if (tempBoard[j + tempY][i + tempX] == 1)\r\n                                return false;\r\n                        }\r\n                        tempBoard[j + tempY][i + tempX] = 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true; // FIXME Task 5: determine whether a placement string is valid\r\n    }\r\n\r\n    /**\r\n     * Given a string describing a placement of pieces, and a location\r\n     * that must be covered by the next move, return a set of all\r\n     * possible next viable piece placements which cover the location.\r\n     *\r\n     * For a piece placement to be viable it must:\r\n     *  - be a well formed piece placement\r\n     *  - be a piece that is not already placed\r\n     *  - not overlap a piece that is already placed\r\n     *  - cover the location\r\n     *\r\n     * @param placement A starting placement string\r\n     * @param col      The location's column.\r\n     * @param row      The location's row.\r\n     * @return A set of all viable piece placements, or null if there are none.\r\n     */\r\n    static Set<String> getViablePiecePlacements(String placement, int col, int row) {\r\n        if (!placement.equals(\"\")){if(! isPlacementValid(placement)){return null;}}\r\n        initial();\r\n        for (int i = 0; i < placement.length()/4; i++){\r\n            String stringForThisPiece = placement.substring(i * 4, i * 4 + 4);\r\n            if (canPieceBePlaced(stringForThisPiece)){\r\n                addToBoard(stringForThisPiece);\r\n            }\r\n        }\r\n        if (Board[row][col]==1){return null;}\r\n        Set<String> box =new HashSet<>();\r\n        String[] direct = {\"N\",\"E\",\"S\",\"W\"};\r\n        String[] T = {\"B\",\"R\",\"G\",\"I\",\"L\",\"N\",\"O\",\"P\",\"S\",\"Y\",\"b\",\"r\",\"g\",\"i\",\"l\",\"n\",\"o\",\"p\",\"s\",\"y\"};\r\n        List<String> A = Arrays.asList(T);\r\n        ArrayList<String> allType = new ArrayList<String>(A);\r\n        for (int i = 0; i < placement.length()/4; i++){\r\n            String low = Character.toString(Character.toLowerCase(placement.charAt(i * 4)));\r\n            String up =  Character.toString(Character.toUpperCase(placement.charAt(i * 4)));\r\n            if (allType.contains(low)||allType.contains(up)){\r\n                allType.remove(low);\r\n                allType.remove(up);\r\n            }\r\n        }\r\n        ArrayList<String> position = new ArrayList<>();\r\n        for (int i=Math.max(0,col-3); i<=col;i++){\r\n            for (int j=Math.max(0,row-3); j<=row;j++){\r\n                position.add(Integer.toString(i) +Integer.toString(j));\r\n            }\r\n        }\r\n        for(String i: direct){\r\n            for(String j: allType){\r\n                for (String posString: position){\r\n                    if (canPieceBePlaced(j+posString+i)){\r\n                        addToBoard(j+posString+i);\r\n                        if(Board[row][col]==1){\r\n                            box.add(j+posString+i);\r\n                        }\r\n                        deleteFromBoard(j+posString+i);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (box.size() !=0){return box;}\r\n        else{return null;}\r\n    }// FIXME Task 6: determine the set of all viable piece placements given existing placements\r\n\r\n    /**\r\n     * Return the solution to a particular challenge.\r\n     **\r\n     * @param challenge A challenge string.\r\n     * @return A placement string describing the encoding of the solution to\r\n     * the challenge.\r\n     */\r\n    public static String getSolution(String challenge) {\r\n        solution = \"\";\r\n        dfs(challenge);\r\n        return solution;\r\n        // FIXME Task 9: determine the solution to the game, given a particular challenge\r\n    }\r\n    //    DFS searching\r\n    public static void dfs(String challenge){\r\n        if(challenge !=null){\r\n            if (challenge.length()==40){\r\n                if(checkCompletion()){\r\n                    solution = challenge ;\r\n                    return;\r\n                }\r\n            }\r\n            Board = new int[][]{{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};\r\n            for (int i = 0; i < challenge.length()/4; i++){\r\n                String stringForThisPiece = challenge.substring(i * 4, i * 4 + 4);\r\n                if (canPieceBePlaced(stringForThisPiece)){\r\n                    addToBoard(stringForThisPiece);\r\n                }\r\n            }\r\n            if (helper()) {\r\n                Set<String> box;\r\n                if (getNextPos() != null) {\r\n                    tlx = getNextPos()[0];\r\n                    tly = getNextPos()[1];\r\n                    box = getViablePiecePlacements(challenge, tly, tlx);\r\n                    if (box != null) {\r\n                        for (String k : box) {\r\n                            addToBoard(k);\r\n                            challenge = sortAdd(challenge, k);\r\n                            dfs(challenge);\r\n                            if (!solution.equals(\"\")){return;}\r\n                            challenge = sortDelete(challenge, k);\r\n                            deleteFromBoard(k);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //     find the next position to place pieces\r\n    public static int[] getNextPos(){\r\n        for (int i=0; i<10;i++){\r\n            for (int j=0;j<5;j++){\r\n                if(Board[j][i]==0){\r\n                    return new int[]{j,i};\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    //    add piece string to the board string\r\n    public static String sortAdd(String a, String Piece){\r\n        String res = \"\";\r\n        ArrayList<String> B = new ArrayList<>();\r\n        for (int i = 0; i < a.length()/4; i++){\r\n            B.add(a.substring(i * 4, i * 4 + 4));\r\n        }\r\n        B.add(Piece);\r\n        Collections.sort(B,String.CASE_INSENSITIVE_ORDER);\r\n        for (String k: B){\r\n            res += k;\r\n        }\r\n        return res;\r\n    }\r\n    //    delete piece string from the board string\r\n    public static String sortDelete(String a, String Piece){\r\n        StringBuilder A = new StringBuilder(a);\r\n        for (int i = 0; i < a.length()/4; i++){\r\n            if (a.substring(i * 4, i * 4 + 4).equals(Piece)){\r\n                return a.substring(0,4*i)+a.substring(4*i+4,a.length());\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    //    stop searching if impossible cases happen (i.e. a blank is surrounded by pieces)\r\n    public static boolean helper(){\r\n//        check corner\r\n        if(Board[0][0]==0 && Board[0][1] == 1 && Board[1][0]==1){return false;}\r\n        if(Board[4][0]==0 && Board[3][0] == 1 && Board[4][1]==1){return false;}\r\n        if(Board[0][9]==0 && Board[1][9] == 1 && Board[0][8]==1){return false;}\r\n        if(Board[4][9]==0 && Board[3][9] == 1 && Board[4][8]==1){return false;}\r\n\r\n\r\n//        check center with 1 blank\r\n        for(int i=1;i<4;i++){\r\n            for(int j=1;j<9;j++){\r\n                if(Board[i][j]==0 && Board[i][j+1] == 1 && Board[i+1][j]==1 && Board[i-1][j] == 1 && Board[i][j-1]==1){\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n//        check edge\r\n        for (int i=1;i<4;i++){\r\n            if (Board[i][0]==0 && Board[i-1][0]==1 && Board[i+1][0]==1 && Board[i][1]==1){return false;}\r\n            if (Board[i][9]==0 && Board[i-1][9]==1 && Board[i+1][9]==1 && Board[i][8]==1){return false;}\r\n        }\r\n        for (int j=1;j<9;j++){\r\n            if (Board[0][j]==0 && Board[0][j+1]==1 && Board[0][j-1]==1 && Board[1][j]==1){return false;}\r\n            if (Board[4][j]==0 && Board[4][j+1]==1 && Board[4][j-1]==1 && Board[3][j]==1){return false;}\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    /** we are going to use DFS to solve this puzzle\r\n     * String DFS(String challenge){}\r\n     * Given a string challenge, we first convert it into a board matrix (5*10)\r\n     * Second, check all pieces on the board and determine which pieces are not on the board\r\n     * create a hashset to store the pieces that we are going to select\r\n     * find the left top position that is not placed on any pieces on the current board matrix\r\n     * if there is no such a position exists, it  means every entry of the board matrix is full\r\n     * then return current string placement\r\n     * if return a top left position, we use getViablePiecePlacements() to find possible pieces set\r\n     * then we use a for loop to select appropriate piece in the set that can be put on the board according to the piece type order\r\n     * if this piece is not in the hashset\r\n     * add the selected piece to the board, also add it to the hashset\r\n     * update the board matrix and corresponding string newplacement\r\n     * recursively to find the new piece: DFS(Sting newplacement)\r\n     * if we cannot find the piece we need, we should traceback to the last top left position and continue the for loop to select new piece\r\n     * delete the previously selected piece from the board\r\n     * update the board matrix\r\n     * update new string placement\r\n     * also delete it from the hashset\r\n     * end the for loop\r\n     */\r\n\r\n    /**\r\n     * This method compares the current string of all the pieces on the board with the final answer.\r\n     * and it will return a string that represent all the pieces that haven't been correctly put.\r\n     * The method is meanly used to show the Hint window while playing\r\n     **\r\n     * @param currentString The current pieces statement on the board.\r\n     * @param gameNum The iNum of the current game.\r\n     *\r\n     * @return A string that represents all the pieces that haven't been correctly placed.\r\n     *         eg: String \"BNiEoW\" means that B/i/o haven't been well placed,\r\n     *         and they should in direction North/East/West.\r\n     */\r\n    public static String findWrongPieces(String currentString, int gameNum){\r\n        String pieceList = \"\";\r\n        String ans = Games.SOLUTIONS[gameNum].placement;\r\n        int piecesNumber = currentString.length() / 4;\r\n        int checkPoint = 0;\r\n        for (int i = 0; i < piecesNumber; i++){\r\n            String realPiece = currentString.substring(i*4, i*4 + 4);\r\n            for (int j = checkPoint; j < 10; j++){\r\n                String correctPiece = ans.substring(j*4, j*4 + 4);\r\n                if (correctPiece.toUpperCase().charAt(0) == realPiece.toUpperCase().charAt(0)){\r\n                    checkPoint = j + 1;\r\n                    if (!correctPiece.equals(realPiece)){\r\n                        pieceList = pieceList + correctPiece.charAt(0) + correctPiece.charAt(3);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return pieceList;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/comp1110/ass2/FitGame.java	(revision fb50fad57b78102fb721928c3711c31e73e1d27c)
+++ src/comp1110/ass2/FitGame.java	(date 1601035497011)
@@ -461,22 +461,29 @@
      *         eg: String "BNiEoW" means that B/i/o haven't been well placed,
      *         and they should in direction North/East/West.
      */
-    public static String findWrongPieces(String currentString, int gameNum){
+    public static String findWrongPieces(String currentString, int gameNum) {
         String pieceList = "";
         String ans = Games.SOLUTIONS[gameNum].placement;
+        System.out.println(ans);
         int piecesNumber = currentString.length() / 4;
         int checkPoint = 0;
-        for (int i = 0; i < piecesNumber; i++){
-            String realPiece = currentString.substring(i*4, i*4 + 4);
-            for (int j = checkPoint; j < 10; j++){
-                String correctPiece = ans.substring(j*4, j*4 + 4);
-                if (correctPiece.toUpperCase().charAt(0) == realPiece.toUpperCase().charAt(0)){
-                    checkPoint = j + 1;
-                    if (!correctPiece.equals(realPiece)){
-                        pieceList = pieceList + correctPiece.charAt(0) + correctPiece.charAt(3);
-                    }
-                    break;
-                }
+        for (int i = 0; i < 10; i++){
+            String correctPiece = ans.substring(i*4, i*4 + 4);
+            String realPiece = currentString.substring(checkPoint*4, checkPoint*4 + 4);
+            if (correctPiece.toUpperCase().charAt(0) == realPiece.toUpperCase().charAt(0)){
+                checkPoint += 1;
+                if (!correctPiece.equals(realPiece)){
+                    pieceList = pieceList + correctPiece.charAt(0) + correctPiece.charAt(3);
+                }
+            }
+            else
+                pieceList = pieceList + correctPiece.charAt(0) + correctPiece.charAt(3);
+            if (checkPoint == piecesNumber){
+                for (int j = i + 1; j < 10; j++){
+                    correctPiece = ans.substring(j*4, j*4 + 4);
+                    pieceList = pieceList + correctPiece.charAt(0) + correctPiece.charAt(3);
+                }
+                break;
             }
         }
         return pieceList;
